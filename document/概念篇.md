## 什么是面向对象编程和面向对象编程语言？

* 面向对象编程(Object Oriented Programming, 简称OOP）：是一种编程规范，具有封装、继承、多态、抽象的特点。
* 面向对象编程语言(Object Oriented Programming Language，简称OOPL）：支持面向对象编程的一种语言，以类和对象为基本的语法机制，并有现成的语法机制来方便的实现面向对象编程的特征（封装、继承、多态、抽象）

## 什么是面向对象分析和面向对象设计？
* 面向对象分析（Object Oriented Analysis, 简称OOA）：在整个面向对象编程时，需要搞清楚要做什么，因此需要分析出来有哪些对象。
* 面向对象设计（Object Oriented Design, 简称OOD）：在整个面向对象编程时，需要搞清楚怎么设计对象与对象之间的关系。
* 面向对象编程：就是将面向对象分析和面向对象设计的结果落地成代码。

* OOA、OOD、OOP三个概念连在一起就是面向对象分析、涉及、编程（实现），正好是面向对象软件开发的三个阶段。

## 什么是UML，我们是否需要UML？

* UML（Unified Model Language, 简称UML）：是一种统一建模语言，在面向对象程序开发过程中，可以用UML来表达面向对象或设计模式的思路。但一般UML语言非常复杂，大家工作的过程中通常会用比较草的UML图来表达程序的设计含义，只要对方能get到你的意思即可~

## 什么是封装？

* 封装（Encapsulation）：对信息隐藏和数据访问保护的一种特性。授权外部仅能通过类提供的方式（或者函数）来访问内部的信息或数据。
  一个例子

* 用一个金融钱包的例子来理解封装的特性
  ```java
  public class Wallet {
  	private String id;
      private long createTime;
      private BigDecimal balance;
      private long balanceLastModifiedTime;
      // ...省略其他属性...
  
      public Wallet() {
       this.id = IdGenerator.getInstance().generate();
       this.createTime = System.currentTimeMillis();
       this.balance = BigDecimal.ZERO;
       this.balanceLastModifiedTime = System.currentTimeMillis();
      }
  
      // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
      public String getId() { return this.id; }
      public long getCreateTime() { return this.createTime; }
      public BigDecimal getBalance() { return this.balance; }
      public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }
  
      public void increaseBalance(BigDecimal increasedAmount) {
          if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
              throw new InvalidAmountException("...");
          }
          this.balance.add(increasedAmount);
          this.balanceLastModifiedTime = System.currentTimeMillis();
      }
  
      public void decreaseBalance(BigDecimal decreasedAmount) {
          if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
              throw new InvalidAmountException("...");
          }
          if (decreasedAmount.compareTo(this.balance) > 0) {
              throw new InsufficientAmountException("...");
          }
          this.balance.subtract(decreasedAmount);
          this.balanceLastModifiedTime = System.currentTimeMillis();
      }
  }
  ```

  从代码中我们可以发现，钱包对象里只有四个属性，id：钱包的唯一标识，createTime：钱包的创建时间，balance：钱包的余额，balanceLastModifiedTime：钱包余额的最后一次更新时间。

* 参考封装特性，钱包类一共提供了如下6个方法来访问或操作钱包的属性：
  ○ String getId()
  ○ long getCreateTime()
  ○ BigDecimal getBalance()
  ○ long getBalanceLastModifiedTime()
  ○ void increaseBalance(BigDecimal increasedAmount)
  ○ void decreaseBalance(BigDecimal decreasedAmount)

* 之所以这么设计，是因为钱包在创建的过程中，id和createTime就一直被指定了，无需外部来修改钱包的这两个属性，而且，这两个属性在初始化的时候就被set进去了， 对于外部调用者也是透明的。

* 对于钱包的balance属性，从业务的角度来说，只能增或者减，不会被重新设置。所以在wallet类中只暴露了increaseBalance和decreaseBalance两个方法来更新balance属性。并且balanceLastModifiedTime也跟increaseBalance和decreaseBalance方法绑定在一起，也保证了balanceLastModifiedTime和balance数据的一致性。

* 总结：
  对于封装这个特性而言，主要是保证内部数据的一种保护措施。在java语言中，变量修饰符（private、public等）就是一种保护措施，可以限制一些范围内的类能访问到类的属性或数据。
  试想一下，如果没有这个限制，那可以在程序的任何一个地方都完成对某个类属性的修改，虽然这种看起来很灵活，但从另一个方面来说，灵活也意味着不可控，属性可以被随意其他的奇葩方式修改，而且修改逻辑可能在代码中的各个角落。势必影响代码的可读性和可扩张性。
  除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性暴露给调用者，调用者想要正确的操作这些属性，就势必要去了解一些业务，这对于调用者来说也是一种负担。如果我们把类仅暴露出一些方法，有方法内部去更新一些属性，那对于调用者而言，减少了负担，也减少了用错的概率。
  这就好比一个冰箱：如果有10个按钮你可能很懵逼，但如果只有2个按钮（藏鲜、冷冻），那你是不是很容易就能把冰箱用好？

## 什么是抽象？
* 封装的概念是把类的属性添加了一些保护措施，以便更好的保护内部的数据，具体表现在如何保护这些数据。而抽象讲的是如何隐藏方法的具体实现，让调用者只需要知道有哪些方法，而不需要知道方法的具体实现。

* 在面向对象的编程中，我们通常会用接口和抽象类来实现抽象这一特性。

* 举个例子来解释抽象
  ```json
  public interface IPictureStorage {
    void savePicture(Picture picture);
    Image getPicture(String pictureId);
    void deletePicture(String pictureId);
    void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
    }
  
  public class PictureStorage implements IPictureStorage {
      // ...省略其他属性...
      @Override
      public void savePicture(Picture picture) { ... }
      @Override
      public Image getPicture(String pictureId) { ... }
      @Override
      public void deletePicture(String pictureId) { ... }
      @Override
      public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
  }
  ```

* 我们在定义接口的方式名时，也要有一定的抽象思维，不要在方法名定义中暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改定义。举个例子，比如getAliyunPictureUrl方法名就不是一个抽象的，假设以后不把图片存在阿里云了，这个方法就不能用了，此时可以把方法名改成getAliyunPicture，把底层的细节给屏蔽掉。
  抽象存在的意义：一方面提高代码的可扩展性、维护性，修改代码不需要更改接口的定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效的过滤掉不必要关注的信息。

## 什么是继承？

* 继承是用来表示类之间的is-a关系。分为两种模式：单继承和多继承。单继承表示一个子类只能继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。`继承主要是用来解决代码复用问题`。
* 举个离职了：如果两个类有一些相同的虎山行和方法，我们就可以将这些相同的代码，抽取到弗雷中，让两个子类继承父类。这样两个子类也就可以重用父类的代码，避免了代码的重复写多遍，提高了**代码的复用性**

## 什么是多态？

* 多态是指子类可以**替换**父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现。比如继承、接口类。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。
* 举个例子：我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类行的功能逻辑，而不是在原有的代码中左修改。这就遵循了**`对修改关闭、对扩展开放`**的设计原则，**提高代码的扩展性**。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，**提高了代码的复用性**。

## 面向过程编程和面向对象编程

* 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组成代码的基本单元（面向对象编程是以类和对象作为组成代码的基本单元），以数据（可以理解成成员变量、属性）与方法相分离为最主要的特点。面向过程是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

* 面向过程的编程语言最大的特性，它不支持类和对象两个语法概念。不支持继承、封装、抽象、多态四种特性。

* 举个例子：

  * 假设我们有一个记录了用户信息的文本文件：users.txt；每行文本的格式是name&age&gender（比如, 小王&28&男）。我们希望写一个程序，从users.txt文件中逐行读取用户信息，然后格式化成name\tage\tgender(其中，\t是分隔符)这种文本格式，并且按照age从小到大排序之后，重新写到另一个文本文件formatted_user.txt中。

  * 针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。

  * 用面向过程的风格写出来的代码如下所示：

    ```c
    struct User {
      char name[64];
      int age;
      char gender[16];
    };
    struct User parse_to_user(char* text) {
      // 将text(“小王&28&男”)解析成结构体struct User
    }
    void sort_users_by_age(struct User users[]) {
      // 按照年龄从小到大排序users
    }
    char* format_to_text(struct User user) {
      // 将结构体struct User格式化成文本（"小王\t28\t男"）
    }
    void format_user_file(char* origin_file_path, char* new_file_path) {
      // open files...
      struct User users[1024]; // 假设最大1024个用户
      int count = 0;
      while(1) { // read until the file is empty
        struct User user = parse_to_user(line);
        users[count++] = user;
      }
      
      sort_users_by_age(users);
      
      for (int i = 0; i < count; ++i) {
        char* formatted_user_text = format_to_text(users[i]);
        // write to new file...
      }
      // close files...
    }
    int main(char** args, int argv) {
      format_user_file("/home/zheng/user.txt", "/home/zheng/formatted_users.txt");
    }
    ```

  * 用面向对象的方式编程

    ```java
    public class User {
      private String name;
      private int age;
      private String gender;
      
      public User(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
      }
      
      public static User praseFrom(String userInfoText) {
        // 将text(“小王&28&男”)解析成类User
      }
      
      public String formatToText() {
        // 将类User格式化成文本（"小王\t28\t男"）
      }
    }
    public class UserFileFormatter {
      public void format(String userFile, String formattedUserFile) {
        // Open files...
        List users = new ArrayList<>();
        while (1) { // read until file is empty 
          // read from file into userText...
          User user = User.parseFrom(userText);
          users.add(user);
        }
        // sort users by age...
        for (int i = 0; i < users.size(); ++i) {
          String formattedUserText = user.formatToText();
          // write to new file...
        }
        // close files...
      }
    }
    public class MainApplication {
      public static void main(String[] args) {
        UserFileFormatter userFileFormatter = new UserFileFormatter();
        userFileFormatter.format("/home/zheng/users.txt", "/home/zheng/formatted_users.txt");
      }
    }
    ```

  * 从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是：**代码的组织方式不同**。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。但说实话，这两者区别不大，没明白面向对象为什么比面向过程好。

## 面向对象比面向过程有哪些优势？

* 主要有三个：
  * 对于大规模复杂程序的开发，程序的处理并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
  * 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些比特性编写出来的代码，更加易扩展、易复用、易维护。
  * 从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比面向过程编程语言更加人性化、更加高级、更加智能（从编程程序的难易程度上可以提现）

## 哪些代码设计看似是面向对象，实际是面向过程的？

* 根据上面格式化txt文件的例子，大家可能会认为：`总以为把所有的代码都塞到类里自然就是在进行面向对象编程了。`实际上，这样的认识是不正确的。有时候，从表面上看似面向对象，实际上是面向过程的风格。
* 举例

### 滥用set、get方法

* 在平常的工作中， 有同事定义完类的属性之后，就顺手把这些属性的set、get方法都定义上。有些同事更加省事，直接用idea或lombok插件（实际上，本人也是这样）。为什么会这么做呢？因为大家都是这么干的，为了以后可以用到，现在定义好，以后用起来会更加方便，而且即使用不到这些set、get方法，把它定义出来也无伤大雅。

* 实际上，这样的做法是不推荐的。它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。比如如下代码：

  ```java
  public class ShoppingCart {
    private int itemsCount;
    private double totalPrice;
    private List<ShoppingCartItem> items = new ArrayList<>();
    
    public int getItemsCount() {
      return this.itemsCount;
    }
    
    public void setItemsCount(int itemsCount) {
      this.itemsCount = itemsCount;
    }
    
    public double getTotalPrice() {
      return this.totalPrice;
    }
    
    public void setTotalPrice(double totalPrice) {
      this.totalPrice = totalPrice;
    }
    public List<ShoppingCartItem> getItems() {
      return this.items;
    }
    
    public void addItem(ShoppingCartItem item) {
      items.add(item);
      itemsCount++;
      totalPrice += item.getPrice();
    }
    // ...省略其他方法...
  }
  ```

  在这段代码中，ShoppiongCart是一个简化后的购物车类，有三个私有（private）属性：itemsCount、totalPrice、items。对于itemsCount、totalPrice两个属性，我们定义了它们的getter、setter方法。对于items属性，我们定义了它的getter方法和addItem()方法。代码很简单，理解起来不难。但实际上这段代码有问题，有什么问题呢？

  我们先来看前两个属性，itemsCount和totalPrice。虽然我们将它们定义成private私有属性，但是提供了public的getter、setter方法，这就跟将两个属性定义为public公有属性没有什么两样了。外部可以通过setter方法随意的修改这两个属性的值。除此之外，任何代码都可以随意调用setter方法，来重新设置itemsCount、totalPrice属性的值，这一会导致其跟items属性的值不一致。

  而面向对象封装的意义是：`通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问来修改内部数据`。所以，就不应该暴露setter方法，明显违反了面向对象的封装特性。数据没有访问权限控制，任何代码都可以随意需改它，代码就退化成了面向过程编程风格了。

  我们再来看一下items属性，定义了它的getter和addItem方法，并没有定义它的setter方法。这样的设计貌似看起来没有什么问题，但实际上并不是。对于itemsCount和totalPrice这两个属性来说，定义一个public的getter方法，确实无伤大雅，毕竟getter方法不会修改数据。但是对于items属性就不一样了，这是因为items属性的getter方法，返回的是一个list容器。外部调用者在拿到这个容器之后，是可以操作容器内部数据的，也就是说，外部代码还是能修改items中的数据。比如这样：

  ```
  ShoppingCart cart = new ShoppingCart();
  cart.getItems().clear(); // 清空购物车
  ```

  你可能会说，清空购物车是一个很常用的功能，这个时候，我们可以在类中添加一个清空的方法，保证购物车的商品金额、商品数量、商品总价是一致的。如下所示：

  ```
  // ...省略其他代码...
    public void clear() {
      items.clear();
      itemsCount = 0;
      totalPrice = 0.0;
    }
  ```

  你可能又会说：查看购物车里买了哪些东西也是很正常的需求，这个时候该怎么办？直接使用getter方法返回的list对象的话，调用者还是能够修改里面的东西。此时我们可以利用java unmodifiedList特性来做，如下所示：

  ```java
  public class ShoppingCart {
    // ...省略其他代码...
    public List<ShoppingCartItem> getItems() {
      return Collections.unmodifiableList(this.items);
    }
  }
  public class UnmodifiableList<E> extends UnmodifiableCollection<E>
                            implements List<E> {
    public boolean add(E e) {
      throw new UnsupportedOperationException();
    }
    public void clear() {
      throw new UnsupportedOperationException();
    }
    // ...省略其他代码...
  }
  ShoppingCart cart = new ShoppingCart();
  List<ShoppingCartItem> items = cart.getItems();
  items.clear();//抛出UnsupportedOperationException异常
  ```

  返回的是一个不可以修改容器内容的list，当外部调用add方法时会抛异常，避免了调用者修改容器数据的问题，保证了封装特性。但实际上这样的设计还是有问题，因为调用者拿到了List对象，也就可以拿到list内部每个元素，进而可以修改每个元素的数据。这个问题该怎么去解决呢？**`这个留到后面的设计模式中去讲解。`**

* 至此，set、get方法的总结就结束了。总而言之就是一句话：在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义setter方法。除此之外，尽管getter方法比setter方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的危险。



### 滥用全局变量和全局方法

* 另外一个违反面向对象编程的例子：滥用全局变量和全局方法。

* 什么是全局变量和全局方法呢？

  ```tex
  在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常亮等。常用的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。静态变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而常量是一种非常常见的全局变量，比如一些中的配置参数，一般都设置为常量，放到一个constants类中。静态方法一把操作静态变量或者外部数据。可以联想一下，我们常用的各种Utils类，里面的方法一般都会定义成静态方法， 可以在不用创建对象的情况下，直接拿来使用。
  ```

* **静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格**。Constants和Utils类最常用到，现在就以这两个类为案例，举例说明：

* 一个常量类

  ```java
  public class Constants {
    public static final String MYSQL_ADDR_KEY = "mysql_addr";
    public static final String MYSQL_DB_NAME_KEY = "db_name";
    public static final String MYSQL_USERNAME_KEY = "mysql_username";
    public static final String MYSQL_PASSWORD_KEY = "mysql_password";
    
    public static final String REDIS_DEFAULT_ADDR = "192.168.7.2:7234";
    public static final int REDIS_DEFAULT_MAX_TOTAL = 50;
    public static final int REDIS_DEFAULT_MAX_IDLE = 50;
    public static final int REDIS_DEFAULT_MIN_IDLE = 20;
    public static final String REDIS_DEFAULT_KEY_PREFIX = "rt:";
    
    // ...省略更多的常量定义...
  }	
  ```

  在这段代码中，我们把程序中所有用到的常量，都集中地放到这个Constants类中。不过，定义一个如此大而全的Constant类，并不是一种很好的设计思路。为什么这么说？原因有这么几点：

  * 当Constants类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改Constants类，都会导致依赖它的类文件重新编译；
  * 如果参与开发同一个项目的工程师有很多，大家可能都会往这个类中添加常量，会提高代码的冲突概率，查找某个常量也会变得非常耗时。
  * 这样的设计还会影响代码的复用性。如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖Constants类。即便这个类只依赖Constants类中的一小部分常量，我们仍需要将整个Constant类也一并引入，也就引入很多无关的常量到新的项目中。

  * 如何改进呢？
    * 将Constants类拆解为功能更加单一的多个类，比如跟MySQL配置相关的常量，我们放到MySqlConstants类中；跟Redis配置相关的类，我们放在RedisConstants类中。
    * 或者就是哪个类中用到了某个常量，就把这个常量放到当前类中。比如RedisConfig类中用到了redis的配置，那就把配置信息放啊到RedisConfig类中。

* 一个utils类。实际上，utils类的出现是基于这么一个问题背景：如果我们有两个类A和B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍。这个时候我们该怎么办呢？通常我们解决代码复用的手段有继承的方式，但是如果两个类并没有继承关系，而是仅仅因为把某个代码复用的片段提取到父类，那这个设计就很奇怪。因此，在创建utils类之前，先问一下自己，可以不可以把这个公共的方法放在父类中，如果不能，那就大胆的定义Utils类吧（**尽管他是面向过程的提现，但这个无法避免**）。

### 定义数据和方法分离的类

* 啥意思呢？基础概念：就是数据定义在一个类中，方法定义在另一个类中。
* 在我们传统的前后端分离项目中，一般会存在Controller层、Service层、Repository层。Controller层负责暴露接口给前端调用，Service层负责核心业务逻辑，Repository层负责数据读写。而在每一层中，我们又会定义相应的VO、BO、Entity。一般情况下，VO、BO、Entity中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的Controller类、Service类、Repository类中。实际上，这种开发模式叫做基于贫血模式的开发模式，也是我们现在非常常用的一种Web项目的开发模式。
* 或许，我们心里都有会很多的疑惑，既然这种开发模式明显违背面向对象的编程风格，为什么大部分Web项目都是基于这种开发模式来开发的呢？**这个留在后面的总结中解答**

## 在面向对象编程中，为什么容易写出面向过程风格的代码？

* 其实这跟我们日常生活中的习惯有关系。在生活中，我们去完成一个任务，一般都会思考，应该先做什么、后做什么， 如何一步步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反，他是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个个的小模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。
* 除此之外，面向对象编程要比面向过程编程更难一点。在面向对象编程中，类的设计还是挺需要技巧，挺需要一定设计经验的。**你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。**基于这几点，很多工程师在开发的过程，更倾向于不太需要动脑子的方式去实现需求，也就不由自主的将代码写成面向过程风格了。



