## 什么是面向对象编程和面向对象编程语言？

* 面向对象编程(Object Oriented Programming, 简称OOP）：是一种编程规范，具有封装、继承、多态、抽象的特点。
* 面向对象编程语言(Object Oriented Programming Language，简称OOPL）：支持面向对象编程的一种语言，以类和对象为基本的语法机制，并有现成的语法机制来方便的实现面向对象编程的特征（封装、继承、多态、抽象）

## 什么是面向对象分析和面向对象设计？
* 面向对象分析（Object Oriented Analysis, 简称OOA）：在整个面向对象编程时，需要搞清楚要做什么，因此需要分析出来有哪些对象。
* 面向对象设计（Object Oriented Design, 简称OOD）：在整个面向对象编程时，需要搞清楚怎么设计对象与对象之间的关系。
* 面向对象编程：就是将面向对象分析和面向对象设计的结果落地成代码。

* OOA、OOD、OOP三个概念连在一起就是面向对象分析、涉及、编程（实现），正好是面向对象软件开发的三个阶段。

## 什么是UML，我们是否需要UML？

* UML（Unified Model Language, 简称UML）：是一种统一建模语言，在面向对象程序开发过程中，可以用UML来表达面向对象或设计模式的思路。但一般UML语言非常复杂，大家工作的过程中通常会用比较草的UML图来表达程序的设计含义，只要对方能get到你的意思即可~

## 什么是封装？

* 封装（Encapsulation）：对信息隐藏和数据访问保护的一种特性。授权外部仅能通过类提供的方式（或者函数）来访问内部的信息或数据。
  一个例子

* 用一个金融钱包的例子来理解封装的特性
  ```java
  public class Wallet {
  	private String id;
      private long createTime;
      private BigDecimal balance;
      private long balanceLastModifiedTime;
      // ...省略其他属性...
  
      public Wallet() {
       this.id = IdGenerator.getInstance().generate();
       this.createTime = System.currentTimeMillis();
       this.balance = BigDecimal.ZERO;
       this.balanceLastModifiedTime = System.currentTimeMillis();
      }
  
      // 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅
      public String getId() { return this.id; }
      public long getCreateTime() { return this.createTime; }
      public BigDecimal getBalance() { return this.balance; }
      public long getBalanceLastModifiedTime() { return this.balanceLastModifiedTime;  }
  
      public void increaseBalance(BigDecimal increasedAmount) {
          if (increasedAmount.compareTo(BigDecimal.ZERO) < 0) {
              throw new InvalidAmountException("...");
          }
          this.balance.add(increasedAmount);
          this.balanceLastModifiedTime = System.currentTimeMillis();
      }
  
      public void decreaseBalance(BigDecimal decreasedAmount) {
          if (decreasedAmount.compareTo(BigDecimal.ZERO) < 0) {
              throw new InvalidAmountException("...");
          }
          if (decreasedAmount.compareTo(this.balance) > 0) {
              throw new InsufficientAmountException("...");
          }
          this.balance.subtract(decreasedAmount);
          this.balanceLastModifiedTime = System.currentTimeMillis();
      }
  }
  ```

  从代码中我们可以发现，钱包对象里只有四个属性，id：钱包的唯一标识，createTime：钱包的创建时间，balance：钱包的余额，balanceLastModifiedTime：钱包余额的最后一次更新时间。

* 参考封装特性，钱包类一共提供了如下6个方法来访问或操作钱包的属性：
  ○ String getId()
  ○ long getCreateTime()
  ○ BigDecimal getBalance()
  ○ long getBalanceLastModifiedTime()
  ○ void increaseBalance(BigDecimal increasedAmount)
  ○ void decreaseBalance(BigDecimal decreasedAmount)

* 之所以这么设计，是因为钱包在创建的过程中，id和createTime就一直被指定了，无需外部来修改钱包的这两个属性，而且，这两个属性在初始化的时候就被set进去了， 对于外部调用者也是透明的。

* 对于钱包的balance属性，从业务的角度来说，只能增或者减，不会被重新设置。所以在wallet类中只暴露了increaseBalance和decreaseBalance两个方法来更新balance属性。并且balanceLastModifiedTime也跟increaseBalance和decreaseBalance方法绑定在一起，也保证了balanceLastModifiedTime和balance数据的一致性。

* 总结：
  对于封装这个特性而言，主要是保证内部数据的一种保护措施。在java语言中，变量修饰符（private、public等）就是一种保护措施，可以限制一些范围内的类能访问到类的属性或数据。
  试想一下，如果没有这个限制，那可以在程序的任何一个地方都完成对某个类属性的修改，虽然这种看起来很灵活，但从另一个方面来说，灵活也意味着不可控，属性可以被随意其他的奇葩方式修改，而且修改逻辑可能在代码中的各个角落。势必影响代码的可读性和可扩张性。
  除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性暴露给调用者，调用者想要正确的操作这些属性，就势必要去了解一些业务，这对于调用者来说也是一种负担。如果我们把类仅暴露出一些方法，有方法内部去更新一些属性，那对于调用者而言，减少了负担，也减少了用错的概率。
  这就好比一个冰箱：如果有10个按钮你可能很懵逼，但如果只有2个按钮（藏鲜、冷冻），那你是不是很容易就能把冰箱用好？

## 什么是抽象？
* 封装的概念是把类的属性添加了一些保护措施，以便更好的保护内部的数据，具体表现在如何保护这些数据。而抽象讲的是如何隐藏方法的具体实现，让调用者只需要知道有哪些方法，而不需要知道方法的具体实现。

* 在面向对象的编程中，我们通常会用接口和抽象类来实现抽象这一特性。

* 举个例子来解释抽象
  ```json
  public interface IPictureStorage {
    void savePicture(Picture picture);
    Image getPicture(String pictureId);
    void deletePicture(String pictureId);
    void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo);
    }
  
  public class PictureStorage implements IPictureStorage {
      // ...省略其他属性...
      @Override
      public void savePicture(Picture picture) { ... }
      @Override
      public Image getPicture(String pictureId) { ... }
      @Override
      public void deletePicture(String pictureId) { ... }
      @Override
      public void modifyMetaInfo(String pictureId, PictureMetaInfo metaInfo) { ... }
  }
  ```

* 我们在定义接口的方式名时，也要有一定的抽象思维，不要在方法名定义中暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改定义。举个例子，比如getAliyunPictureUrl方法名就不是一个抽象的，假设以后不把图片存在阿里云了，这个方法就不能用了，此时可以把方法名改成getAliyunPicture，把底层的细节给屏蔽掉。
  抽象存在的意义：一方面提高代码的可扩展性、维护性，修改代码不需要更改接口的定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效的过滤掉不必要关注的信息。

## 什么是继承？

* 继承是用来表示类之间的is-a关系。分为两种模式：单继承和多继承。单继承表示一个子类只能继承一个父类，多继承表示一个子类可以继承多个父类。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。`继承主要是用来解决代码复用问题`。
* 举个离职了：如果两个类有一些相同的虎山行和方法，我们就可以将这些相同的代码，抽取到弗雷中，让两个子类继承父类。这样两个子类也就可以重用父类的代码，避免了代码的重复写多遍，提高了**代码的复用性**

## 什么是多态？

* 多态是指子类可以**替换**父类，在实际的代码运行过程中，调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现。比如继承、接口类。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。
* 举个例子：我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类行的功能逻辑，而不是在原有的代码中左修改。这就遵循了**`对修改关闭、对扩展开放`**的设计原则，**提高代码的扩展性**。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，**提高了代码的复用性**。

## 面向过程编程和面向对象编程

* 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组成代码的基本单元（面向对象编程是以类和对象作为组成代码的基本单元），以数据（可以理解成成员变量、属性）与方法相分离为最主要的特点。面向过程是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

* 面向过程的编程语言最大的特性，它不支持类和对象两个语法概念。不支持继承、封装、抽象、多态四种特性。

* 举个例子：

  * 假设我们有一个记录了用户信息的文本文件：users.txt；每行文本的格式是name&age&gender（比如, 小王&28&男）。我们希望写一个程序，从users.txt文件中逐行读取用户信息，然后格式化成name\tage\tgender(其中，\t是分隔符)这种文本格式，并且按照age从小到大排序之后，重新写到另一个文本文件formatted_user.txt中。

  * 针对这样一个小程序的开发，我们一块来看看，用面向过程和面向对象两种编程风格，编写出来的代码有什么不同。

  * 用面向过程的风格写出来的代码如下所示：

    ```c
    struct User {
      char name[64];
      int age;
      char gender[16];
    };
    struct User parse_to_user(char* text) {
      // 将text(“小王&28&男”)解析成结构体struct User
    }
    void sort_users_by_age(struct User users[]) {
      // 按照年龄从小到大排序users
    }
    char* format_to_text(struct User user) {
      // 将结构体struct User格式化成文本（"小王\t28\t男"）
    }
    void format_user_file(char* origin_file_path, char* new_file_path) {
      // open files...
      struct User users[1024]; // 假设最大1024个用户
      int count = 0;
      while(1) { // read until the file is empty
        struct User user = parse_to_user(line);
        users[count++] = user;
      }
      
      sort_users_by_age(users);
      
      for (int i = 0; i < count; ++i) {
        char* formatted_user_text = format_to_text(users[i]);
        // write to new file...
      }
      // close files...
    }
    int main(char** args, int argv) {
      format_user_file("/home/zheng/user.txt", "/home/zheng/formatted_users.txt");
    }
    ```

  * 用面向对象的方式编程

    ```java
    public class User {
      private String name;
      private int age;
      private String gender;
      
      public User(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
      }
      
      public static User praseFrom(String userInfoText) {
        // 将text(“小王&28&男”)解析成类User
      }
      
      public String formatToText() {
        // 将类User格式化成文本（"小王\t28\t男"）
      }
    }
    public class UserFileFormatter {
      public void format(String userFile, String formattedUserFile) {
        // Open files...
        List users = new ArrayList<>();
        while (1) { // read until file is empty 
          // read from file into userText...
          User user = User.parseFrom(userText);
          users.add(user);
        }
        // sort users by age...
        for (int i = 0; i < users.size(); ++i) {
          String formattedUserText = user.formatToText();
          // write to new file...
        }
        // close files...
      }
    }
    public class MainApplication {
      public static void main(String[] args) {
        UserFileFormatter userFileFormatter = new UserFileFormatter();
        userFileFormatter.format("/home/zheng/users.txt", "/home/zheng/formatted_users.txt");
      }
    }
    ```

  * 从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是：**代码的组织方式不同**。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。但说实话，这两者区别不大，没明白面向对象为什么比面向过程好。

## 面向对象比面向过程有哪些优势？

* 主要有三个：

  * 对于大规模复杂程序的开发，程序的处理并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程，更能应对这种复杂类型的程序开发。
  * 面向对象编程相比面向过程编程，具有更加丰富的特性（封装、抽象、继承、多态）。利用这些比特性编写出来的代码，更加易扩展、易复用、易维护。
  * 从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比面向过程编程语言更加人性化、更加高级、更加智能（从编程程序的难易程度上可以提现）

  



