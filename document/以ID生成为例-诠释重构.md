# 以一个能生成id的功能性代码重构成好的生成id的代码

## ID生成器的背景

* 我们可以为每个请求分配一个唯一ID，并且保存在请求的上下文中（threadLocal）。每次打印日志的时候，我们从请求上下文中取出请求ID，跟日志一块输出。这样，同一个请求的所有日志都包含同样的请求ID信息，我们就可以通过请求ID来搜索同一个请求的所有日志了。

## 一份能用代码实现

* 假设leader让小王负责这个ID生成器的开发。对于稍微有点开发经验的程序员来说，实现这样一个简单的ID生成器，并不是件难事。如下所示：

  ```java
  public class IdGenerator {
    private static final Logger logger = LoggerFactory.getLogger(IdGenerator.class);
    public static String generate() {
      String id = "";
      try {
        String hostName = InetAddress.getLocalHost().getHostName();
        String[] tokens = hostName.split("\\.");
        if (tokens.length > 0) {
          hostName = tokens[tokens.length - 1];
        }
        char[] randomChars = new char[8];
        int count = 0;
        Random random = new Random();
        while (count < 8) {
          int randomAscii = random.nextInt(122);
          if (randomAscii >= 48 && randomAscii <= 57) {
            randomChars[count] = (char)('0' + (randomAscii - 48));
            count++;
          } else if (randomAscii >= 65 && randomAscii <= 90) {
            randomChars[count] = (char)('A' + (randomAscii - 65));
            count++;
          } else if (randomAscii >= 97 && randomAscii <= 122) {
            randomChars[count] = (char)('a' + (randomAscii - 97));
            count++;
          }
        }
        id = String.format("%s-%d-%s", hostName,
                System.currentTimeMillis(), new String(randomChars));
      } catch (UnknownHostException e) {
        logger.warn("Failed to get the host name.", e);
      }
      return id;
    }
  }
  ```

  上面的代码生成的ID实例如下所示。整个ID由三个部分组成。第一部分是本机名称的最后一个字段。第二部分是当前时间戳，精确到毫秒。第三部分是8位的随机字符串，包含大小写字母和数字。尽管这样生成的ID并不是绝对唯一的，有重复的可能，但事实上重复的概率非常低。对于我们的日志追踪来说，极小概率的ID重复是完全可以接受的。

  ```text
  103-1577456311467-3nR3Do45
  103-1577456311468-0wnuV5yw
  103-1577456311468-sdrnkFxN
  103-1577456311468-8lwk0BP0
  ```

  不过，这份代码只能算得上“能用”，勉强合格。为什么这么说呢？这段代码只有短短不到40行，里面却有很多值得优化的地方。

* **首先idGenerator设计成了实现类而非接口，调用者直接依赖实现而非接口。违反了基于接口而非实现编程的设计思想**。实际上，将IdGenerator设计成实现类，而不定义成接口，问题也不大。如果哪天ID生成算法改变了，我们只需要直接修改实现类的代码即可。但是如果项目中需要同时存在两种ID生成算法，也就是同时需要存在两个IdGenerator实现类。比如，我们需要将这个框架给更多的系统使用，系统在使用的时候可以灵活的选择它需要的生成算法，这个时候，我们就需要将IdGenerator定义为接口，并且为不同的生成算法定义不同的实现类。

* 其次，虽然IdGenerator只包含一个函数，并且代码行数也不多，但代码的可读性并不好。特别是随机字符串生成的那部分代码，一方面，代码完全没有注释，生成算法比较难读懂。另一方面，代码里有很多魔法数，严重影响代码的可读性。



## 重构代码：优化可读性

* 删除代码中的魔法数字

* 将部分复杂的代码抽取成方法

* 基于接口而非实现

* 添加适当注释，增加可读性（包含why、what、how三个部分）

* 优化后的代码如下所示：

  ```java
  /**
   * Id Generator that is used to generate random IDs.
   *
   * <p>
   * The IDs generated by this class are not absolutely unique,
   * but the probability of duplication is very low.
   */
  public class RandomIdGenerator implements LogTraceIdGenerator {
    private static final Logger logger = LoggerFactory.getLogger(RandomIdGenerator.class);
    /**
     * Generate the random ID. The IDs may be duplicated only in extreme situation.
     *
     * @return an random ID
     */
    @Override
    public String generate() {
      //...
    }
    /**
     * Get the local hostname and
     * extract the last field of the name string splitted by delimiter '.'.
     *
     * @return the last field of hostname. Returns null if hostname is not obtained.
     */
    private String getLastfieldOfHostName() {
      //...
    }
    /**
     * Get the last field of {@hostName} splitted by delemiter '.'.
     *
     * @param hostName should not be null
     * @return the last field of {@hostName}. Returns empty string if {@hostName} is empty string.
     */
    @VisibleForTesting
    protected String getLastSubstrSplittedByDot(String hostName) {
      //...
    }
    /**
     * Generate random string which
     * only contains digits, uppercase letters and lowercase letters.
     *
     * @param length should not be less than 0
     * @return the random string. Returns empty string if {@length} is 0
     */
    @VisibleForTesting
    protected String generateRandomAlphameric(int length) {
      //...
    }
  }
  ```

  