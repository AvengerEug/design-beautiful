## 一、（实战一）针对业务系统的开发，如何做需求分析和设计

* 对于一个工程师来说，如果要追求长远发展，就不能一直只把自己放在执行者的角色，不能只是一个代码实现者，你还要有独立负责一个系统的能力，能端到端开发一个完整的系统。这其中的工作就包括：前期的需求沟通分析、中期的代码设计实现、后期的系统上线运维等。
* 此次实战的目的：通过一个积分兑换系统的开发实战，一方面展示一个业务系统从需求分析到上线运维的整个开发套路，让你能举一反三的应用到所有其他系统的开发中；另一方面也展示在看似没有技术含量的业务开发中，实际上都蕴含了哪些设计原则、思想、模式。

## 需求分析

* 积分是一种常见的营销手段，很多产品都会通过它来促进消费、增加用户黏性，比如淘宝积分、信用卡积分、商场消费积分等等。假设你是一家类似淘宝的这样的电商平台的工程师，平台暂时还没有积分系统。Leader希望由你来负责开发这样一个系统，你会如何来做呢？

* 你可能会说，只要产品经理给我产品设计文档（PRD）、线框图，我照着实现就可以了。其实，这种想法有点狭隘。技术人员应该更多地参与到产品设计中，一个优秀的工程师会具备产品思维，并不是完全的技术控。

* 那作为技术人，如何来做产品设计呢？首先，一定不要自己一个人闷头想。一方面，这样做很难想全面。另一方面，从零开始设计也比较浪费时间。**我们可以找几个类似的产品，比如淘宝，看看它们是如何设计积分系统的，然后借鉴到自己的产品中。你可以自己亲自用用淘宝，看看积分是怎么使用的，也可以直接百度一下积“淘宝积分规则”**。基于这两个输入，我们基本上就能大致摸清楚积分系统该如何设计了。除此之外，我们还要了解公司的产品，将借鉴来的东西糅合在我么自己的产品中，并做适当的微创新。

* 笼统地来讲，积分系统无外乎就两个大的功能点，**一个是赚取积分，另一个是消费积分**。**赚取积分功能**包括积分赚取渠道，比如下订单、每日签到、评论等；还包括**积分兑换规则**，比如订单金额与积分的兑换比例，每日签到赠送多少积分等等。**消费积分功能**包括消费渠道，比如抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等；还包括积分兑换规则，比如多少积分可以换算成抵扣订单的多少金额，一张优惠券需要多少积分来兑换等等。

* 上面阐述的只是几个大的点，每个点内部可能会有很多细节。我们要通过**线框图、用户用例来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。**`(以用户的视角来想case，来套整个流程，看是否行得通，如果行不通，则看哪里需要改动下。其实就是：模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。)`

* 比如：有关积分有效期的用例，我们可以进行如下的设计：

  * 用户在获取积分的时候，会告知积分的有效期；
  * 用户在使用积分的时候，会有限使用快过期的积分；
  * 用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）；
  * 用户在查询总可用积分的时候，会排除掉过期的积分。

  通过上面的讲的方法，我们就可以将功能需求大致弄清楚了。

### 1. 积分赚钱和兑换规则

* 积分的赚取渠道包括：下订单、每日签到、评论等。
* 积分兑换规则可以是比较通用的。比如，签到送10积分。再比如，按照订单总金额的10%兑换成积分，也就是100块钱的订单可以积累10积分。除此之外，积分兑换规则也可以是比较细化的。比如，不同的店铺、不同的商品可以设置不同的积分兑换比例。
* 对于积分的有效期，我们可以根据不同渠道，设置不同的有效期。积分到期之后会作废；在消费积分的时候，优先使用快到期的积分。

### 2. 积分消费和兑换规则

* 积分的消费渠道包括：抵扣订单金额、兑换消费券、积分换购、参与活动扣积分等等
* 我们可以根据不同的消费渠道，设置不同的积分规则。比如，积分换算成消费抵扣金额的比例是10%，也就是10积分可以抵扣1块钱；100积分可以兑换15块钱的优惠券等。

### 3. 积分及其明细查询

* 查询用户的总积分，以及赚取积分和消费积分的历史记录。

## 系统设计

* 面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。

#### 1. 合理地将功能划分到不同模块

* 在学习面向对象设计的时候，我们有总结到：面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然，那代码的质量就不会差到哪里去。类比面向对象设计，系统设计实际上就是将合适的功能放在合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。

* 以用户下订单，增加用户积分的功能为例，我们通过简单的推演，看如下的三种流程哪种更加合适。

  * 流程一：用户下单 -> 订单系统异步发送消息或同步调用营销系统的接口 -> 积分系统根据拿到的订单id查询订单对应的积分兑换规则（兑换比例、有效期等）计算得到订单可兑换的积分数量 -> 调用积分系统接口给用户增加积分

    > 这种流程下，营销系统需要根据订单id找到对应的商品，再根据商品找到对应的积分兑换规则。

  * 流程二：用户下单 -> 订单系统根据订单id找出购买的商品，拿到商品对应的积分兑换规则 -> 调用积分系统给用户增加积分。

    > 这种流程下，订单系统需要感知营销系统的功能，并且计算积分规则的逻辑散落在各个角落（所有需要加积分的入口），比较零散

  * 流程三：用户下单 -> 订单系统异步发送消息或同步调用积分系统的接口 -> 积分系统根据订单id获取购买的商品，再计算积分兑换规则，再给用户加积分

    > 这个流程下，积分系统需要反向依赖订单系统的富客户端（需要查订单信息）

  * 那这三种流程哪种合适呢？其实都能实现功能，具体是否合理，就是要看系统的分层了。如果系统的分层是订单系统与营销系统同级，积分系统是最底层的基础功能。那可以选择流程一。流程二不推荐，因为订单系统感知了营销的计算逻辑。如果积分系统和营销系统定位成同一个系统，那流程三也是ok的**。判断是否合理，就看模块的分层，我们只需要知道，上层模块可以依赖下层或同级模块，同时也可以包含下层业务的信息。但下层模块不可以反向依赖上层模块。**

#### 2. 设计模块与模块之间的交互关系

* 在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互
* 通常，上下层系统之间的调用倾向于通过同步接口，同层之间的调用依赖倾向于异步消息调用。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用（需要依赖二方包）。

#### 3. 设计模块的接口、数据库、业务模型

* 业务系统本身的设计无外乎有这样三方面的工作要做：接口设计、数据库设计和业务模型设计。

## 二、（实战二）如何实现一个遵从设计原则的积分兑换系统

### 1. 为什么要用MVC三层开发？

#### 代码复用

* 同一个Repository可能被多个Service调用，同一个Service可能被多个Controller调用。比如UserService中的getUserById接口封装了通过Id获取用户信息的逻辑，这部分逻辑可能会被UserController和AdminController等多个Controller使用。如果没有Service层，每个Controller都是重复实现这部分逻辑，显然违反了**DRY原则（指写了重复代码）**

#### 隔离作用

* 分层提现了一种抽象和封装的设计思想。比如Repository层封装了对数据库的访问操作，提供了抽象的数据访问接口，**体现了基于接口而非实现编程的设计思想**
* Service层使用Repository层提供的接口，并不关系其底层依赖的到底是哪种数据库。当我们需要替换数据库的时候，比如从MySQL到Oracle，从Oralce到Redis，只需要改动Repository层的代码即可
* 除此之外，Controller、Service、Repository三层代码的稳定程度不同、引起变化的原因不同，所以分层三层能有效地隔离变化。比如，Repository层基于数据库表，而数据库表改动的可能性很小，所以Repository层最稳定，而Controller层提供适配给外部使用的接口，代码经常会变动。分层之后，Controller层中代码的频繁改动并不会影响到稳定的Repository层。

#### 隔离关注点

* Repository层只关系数据的读写。Service层只关注业务逻辑，不管数据的来源。Controller层只关注与外界打交道，提供数据校验、封装、格式转换功能，并不关心业务逻辑。**分层之后，职责分明，更加符合单一职责设计原则，代码的内聚性更好**。

#### 提高代码的可测试性

* 当我们要测试Service代码时，我们可以不依赖Repository层的代码，可以自己组装数据构建成Entity对象。

#### 应对系统的复杂性

* 所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。此时，我们需要想办法拆分，一般的手段有：垂直拆分和水平拆分。水平拆分一般是基于业务来做拆分，就是模块化；垂直拆分就是基于流程来做拆分。

#### 总结

* 不管是分层、模块化还是OOP、DDD、以及各种设计模式、原则、思想，都是为了应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是我们常说的“杀鸡焉用牛刀”

### Entity、BO、VO存在的意义是什么

* Entity、BO、VO分别对应的是Repository、Service、Controller层的领域模型对象。在实际开发中，Entity、BO、VO内部可能存在大量的重复字段，甚至三者包含的字段完全一样。我们有必要这样去定义三个领域模型对象吗？答案是有必要。假设我们目前操作的是用户的这样领域模型，有一个字段是password，Entity、BO可以存储用户密码的明文信息，但是在VO中还能往外透传吗？你可能又会问：Entity、BO、VO内部可能存在大量的重复字段，违反了DRY原则吗？答案是不违反。为了分层清晰、减少耦合，多维护几个模型对象的成本也不是不能接受的，如果你真的有代码洁癖，则可以用继承和组合来解决重复字段的问题~

### 2. 我们在做业务需求中有用到哪些设计原则和思想

| 设计原则和思想       | 备注                                                         |
| -------------------- | ------------------------------------------------------------ |
| 高内聚、低耦合       | 我们将积分兑换系统划分成订单系统、营销系统、积分系统，遵从的划分原则就是让模块本身高内聚（想同功能点放在同一个模块中），让模块之间低耦合（订单、营销、积分相互隔离） |
| 单一职责原则         | 我们的MVC分层结构就是遵循了单一职责。Repository层只负责与数据库交互，Service只负责处理业务逻辑，Controller层只负责与前端交互、数据校验和数据转换 |
| 依赖注入原则         | 通常会用spring框架的依赖注入功能，将Repository层注入到Service层，将Service层注入到Controller层 |
| 依赖反转原则         | 通过spring ioc容器来管理对象的创建、生命周期就用到了依赖反转原则 |
| 基于接口而非实现编程 | 在mvc三层结构的代码实现中，Service层使用Repository层提供的接口，并不关系其底层具体依赖的是哪个数据库，遵从基于接口而非实现编程的设计思想 |
| 封装、抽象           | 分层体现了抽象和封装的设计原则，能够隔离变化，隔离关注点     |
| DRY与继承和组合      | 尽管Entity、BO、VO存在代码重复，但功能语义不同，并不违反DRY原则。为了解决三者之间存在的代码重复问题，我们可以用继承和组合解决 |
| 面向对象设计         | 面向对象设计本质是将合适的代码放到合适的类中，系统设计是将合适的功能放到合适的模块中 |



## 三、（实战三）针对非业务性的通用框架如何做需求分析

* 项目背景：希望设计开发一个小的框架，能够获取接口调用的各种统计信息，比如：响应时间的最大值（max）、最小值（min）、平均值（avg）、百分位值（percentile）、接口调用次数（count）、频率（tps）等，并且支持将统计结果以各种显示格式（比如：JSON格式、网页格式、自定义显示格式等）输出到各种终端（Console命令行、HTTP网页、Email、日志文件、自定义输出终端等），以方便查看。
* 系统流程（模块）：
  * 数据采集 -> 存储 -> 聚合统计 -> 显示
* **如果我们总是等到所有的东西都准备好了再开始，那这件事可能永远都开始不了。**如果我们等着把所有的功能都ready后再做，那这会耗费巨大的时间，同时也会给老板一种不可控的印象分。正确的方式应该为：小步快跑，快速迭代。我们应该先完成一些基础的功能，对于一些高级的功能，我们再放在后面的迭代中去优化，2.0、3.0版本的优化等等。
