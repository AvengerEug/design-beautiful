# 以面向对象的思维设计鉴权功能。
## 鉴权功能推演
### 1.0版本
* 最简单的解决方案就是：通过用户名+密码来做认证。我们给每个允许访问我们服务的调用方，派发一个应用名（或者叫应用Id、appId）和一个对应的密码（或者叫秘钥）。调用方每次进行接口请求的时候，都鞋带自己的AppId和密码。微服务在接收到接口调用请求之后，会解析出AppId和密码，跟存储在为服务端的appId和密码进行比对。如果一致，说明认证成功，则允许接口调用请求；否则就拒绝接口的调用请求。

### 2.0版本
* 在1.0版本中每次都要明文传输密码。密码很容易被截获，是不安全的。如果我们借助加密算法（比如SHA），对密码进行加密之后，再传递到微服务端验证，是不是就可以了呢？实际上这样也是不安全的，因为机密之后的密码及AppID照相可以被未认证系统（或者说黑客）截获（通过抓包工具），未认证系统可以携带这个加密之后的密码以及对应的AppID，伪装成已认证系统来访问我们的接口。这就是典型的“重放攻击”。
* 提出问题，然后再解决问题，是一个非常好的迭代优化方法。对于刚刚提出的问题，我们可以借助OAuth的验证思路来解决
   * 调用方将请求接口的URL跟AppId、密码凭借在一起，然后进行加密，生成一个token。调用方在进行接口请求的时候，将token及AppId随url一块传递给微服务端。微服务端接收到这些数据之后，根据AppID从数据库中取出对应的密码，并通过同样的算法生成token，生成另外一个token。用新token跟调用方传递过来的token做对比。如果一致则允许接口调用请求。否则则拒绝请求。
   * 但这样的方式还是有问题，因为黑客可以通过抓包工具把这一串请求数据劫持，然后重放请求，那黑客就可以以同样的请求调用这个接口。如果这个接口没有做幂等操作，则可能会出现很多的脏数据。
   
### 3.0 版本
* 2.0的版本有一个问题，就是针对同一个case而言，请求参数和token都是固定的，我们可以在2.0的基础上再加一个参数：
    * 当前请求的时间戳, key为timestamp，value为当前请求的发起的时间
    * 微服务端接收到请求后，先取出timestamp参数，判断是否超过1分钟（这个可以配置），如果超过1分钟则拒绝请求。如果小于1分钟，则继续走后续的鉴权流程
* 3.0的版本新增了一个时间戳的参数，保证了黑客劫持请求后，只能根据服务端配置的超时时间来回放请求。如果我们配置timestamp为10s，那黑客劫持请求后，也只能在10s内发起请求，超过10s服务器就会拒绝。
* 3.0版本也有缺陷，会有一个时间窗口会黑客利用。但是攻与守之间本身就没有绝对的安全。**`我们能做的就是，尽量提高攻击成本`**。 
   